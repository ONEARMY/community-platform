"use strict";(self.webpackChunkoa_docs=self.webpackChunkoa_docs||[]).push([[68],{6064:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});var t=i(4848),s=i(8453);const c={},r="Technical Decisions",a={id:"technical-decisions",title:"Technical Decisions",description:"Multi-tenant",source:"@site/docs/technical-decisions.md",sourceDirName:".",slug:"/technical-decisions",permalink:"/technical-decisions",draft:!1,unlisted:!1,editUrl:"https://github.com/ONEARMY/community-platform/edit/master/packages/documentation/docs/technical-decisions.md",tags:[],version:"current",frontMatter:{}},o={},l=[{value:"Multi-tenant",id:"multi-tenant",level:2},{value:"Comment Counts",id:"comment-counts",level:2},{value:"Research Search",id:"research-search",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"technical-decisions",children:"Technical Decisions"})}),"\n",(0,t.jsx)(n.h2,{id:"multi-tenant",children:"Multi-tenant"}),"\n",(0,t.jsx)(n.p,{children:"Multi-tenancy is a requirement because:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Single login for all websites."}),"\n",(0,t.jsx)(n.li,{children:"Easier maintenance and migrations."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"With supabase there are a few ways we can do multi-tenancy:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Have Multiple projects"}),"\n",(0,t.jsx)(n.li,{children:"Have a Single project with multiple schemas"}),"\n",(0,t.jsx)(n.li,{children:"Have a Single project, with 1 common schema, using RLS (Row Level Security) to ensure data separation"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Decision: 3. Why?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A single project is easier to manage and deploy"}),"\n",(0,t.jsx)(n.li,{children:"Same for a single common schema... and multiple schemas wouldn't give any security benefits"}),"\n",(0,t.jsx)(n.li,{children:"With RLS, we can ensure, based on an Environment Variable, only the respective rows of that tenant are queried."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"How?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each table has a tenant_id column"}),"\n",(0,t.jsx)(n.li,{children:"On each request, to supabase (via its sdk) we pass a header 'x-tenant-id' with the process.env.TENANT_ID variable, which is set for each app, via Fly.io secret."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"comment-counts",children:"Comment Counts"}),"\n",(0,t.jsx)(n.p,{children:"Currently we can sort questions/research/library by the number of comments.\nWith supabase there are a few ways we can do this:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A comment count view"}),"\n",(0,t.jsx)(n.li,{children:"A comment count materialized view"}),"\n",(0,t.jsx)(n.li,{children:"Triggers, where the main table has a comment_count column which is updated when a comment is inserted/deleted"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Decision: 3. Why?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A simple view isn't performant, would be querying for the total on each query."}),"\n",(0,t.jsx)(n.li,{children:"A materialized view keeps state and is simple enough to update it, but doesn't support RLS. (Would be a better contender if it supported RLS)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"How?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Whenever a comment is created or deleted, it triggers the update_comment_count function."}),"\n",(0,t.jsx)(n.li,{children:"The function checks the Operation kind (Insert/Delete), the source_type and source_id."}),"\n",(0,t.jsx)(n.li,{children:"From the source_type it will update the according content total (library, research, questions) that matches the source_id"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"research-search",children:"Research Search"}),"\n",(0,t.jsx)(n.p,{children:"Research is composed by:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"research main item"}),"\n",(0,t.jsx)(n.li,{children:"research updates"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["When searching for ",(0,t.jsx)(n.code,{children:"research"}),", we want to search both the main item and its updates.\nTo search using postgres textSearch, all info needs to be stored in a vector column.\nIf updates were stored in the main research item as json, it would be straightforward to index.\nHaving updates being stored in their own table is beneficial:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"easier CRUD"}),"\n",(0,t.jsx)(n.li,{children:"enforcing a schema ensures data integrity and structure compared to json"}),"\n",(0,t.jsx)(n.li,{children:"easier to extract metrics"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The solution is to have a ",(0,t.jsx)(n.code,{children:"tsvector"})," column that also contains update data which comes from the ",(0,t.jsx)(n.code,{children:"research_updates"})," table.\nTo build the column data, a ",(0,t.jsx)(n.code,{children:"combined_research_search_fields(research_id)"})," is used to combine all data (main + updates).\nTo automate indexing from ",(0,t.jsx)(n.code,{children:"research_update"})," an INSERT/UPDATE trigger is needed."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},c=t.createContext(s);function r(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);