{"version":3,"file":"LinkifyText-35502f20.js","sources":["../../../../node_modules/linkifyjs/dist/linkify.es.js","../../../../node_modules/linkify-plugin-mention/dist/linkify-plugin-mention.es.js","../../../../node_modules/linkify-react/dist/linkify-react.es.js","../../src/LinkifyText/LinkifyText.tsx"],"sourcesContent":["// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3barth4b_ott3vie4c1le2ogado5udhabi7c_ademy5centure6ountant_s9o1tor4d_s1ult4e_g1ro2tna4f_l1rica5g_akhan5ency5i_g1rbus3force5tel5kdn3l_faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m_azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o_l2partments8p_le4q_uarelle8r_ab1mco4chi3my2pa2t_e3s_da2ia2sociates9t_hleta5torney7u_ction5di_ble3o3spost5thor3o_s4vianca6w_s2x_a2z_ure5ba_by2idu3namex3narepublic11d1k2r_celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b_c1t1va3cg1n2d1e_ats2uty4er2ntley5rlin4st_buy5t2f1g1h_arti5i_ble3d1ke2ng_o3o1z2j1lack_friday9ockbuster8g1omberg7ue3m_s1w2n_pparibas9o_ats3ehringer8fa2m1nd2o_k_ing5sch2tik2on4t1utique6x2r_adesco6idgestone9oadway5ker3ther5ussels7s1t1uild_ers6siness6y1zz3v1w1y1z_h3ca_b1fe2l_l1vinklein9m_era3p2non3petown5ital_one8r_avan4ds2e_er_s4s2sa1e1h1ino4t_ering5holic7ba1n1re2s2c1d1enter4o1rn3f_a1d2g1h_anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i_priani6rcle4sco3tadel4i_c2y_eats7k1l_aims4eaning6ick2nic1que6othing5ud3ub_med6m1n1o_ach3des3ffee4llege4ogne5m_cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking_channel11l1p2rsica5untry4pon_s4rses6pa2r_edit_card4union9icket5own3s1uise_s6u_isinella9v1w1x1y_mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e_al_er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si_gn4v2hl2iamonds6et2gital5rect_ory7scount3ver5h2y2j1k1m1np2o_cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c_o2deka3u_cation8e1g1mail3erck5nergy4gineer_ing9terprises10pson4quipment8r_icsson6ni3s_q1tate5t_isalat7u_rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n_s2rm_ers5shion4t3edex3edback6rrari3ero6i_at2delity5o2lm2nal1nce1ial7re_stone6mdale6sh_ing5t_ness6j1k1lickr3ghts4r2orist4wers5y2m1o_o_d_network8tball6rd1ex2sale4um3undation8x2r_ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n_d2rniture7tbol5yi3ga_l_lery3o1up4me_s3p1rden4y2b_iz3d_n2e_a1nt_ing5orge5f1g_ee3h1i_ft_s3ves2ing5l_ass3e1obal2o4m_ail3bh2o1x2n1odaddy5ld_point6f2o_dyear5g_le4p1t1v2p1q1r_ainger5phics5tis4een3ipe3ocery4up4s1t1u_ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc_bank7ealth_care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k_t2m1n1ockey4ldings5iday5medepot5goods5s_ense7nda3rse3spital5t_ing5t_eles2s3mail5use3w2r1sbc3t1u_ghes5yatt3undai7ibm2cbc2e1u2d1e_ee3fm2kano4l1m_amat4db2mo_bilien9n_c1dustries8finiti5o2g1k1stitute6urance4e4t_ernational10uit4vestments10o1piranga7q1r_ish4s_maili5t_anbul7t_au2v3jaguar4va3cb2e_ep2tzt3welry6io2ll2m_p2nj2o_bs1urg4t1y2p_morgan6rs3uegos4niper7kaufen5ddi3e_rryhotels6logistics9properties14fh2g1h1i_a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p_mg2n2r_d1ed3uokgroup8w1y_oto4z2la_caixa5mborghini8er3ncaster5ia3d_rover6xess5salle5t_ino3robe5w_yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i_dl2fe_insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan_s3cker3us3l1ndon4tte1o3ve3pl_financial11r1s1t_d_a3u_ndbeck6xe1ury5v1y2ma_cys3drid4if1son4keup4n_agement7go3p1rket_ing3s4riott5shalls7serati6ttel5ba2c_kinsey7d1e_d_ia3et2lbourne7me1orial6n_u2rckmsd7g1h1iami3crosoft7l1ni1t2t_subishi9k1l_b1s2m_a2n1o_bi_le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to_rcycles9v_ie4p1q1r1s_d2t_n1r2u_seum3ic3tual5v1w1x1y1z2na_b1goya4me2tura4vy3ba2c1e_c1t_bank4flix4work5ustar5w_s2xt_direct7us4f_l2g_o2hk2i_co2ke1on3nja3ssan1y5l1o_kia3rthwesternmutual14on4w_ruz3tv4p1r_a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan_group9dnavy5lo3m_ega4ne1g1l_ine5oo2pen3racle3nge4g_anic5igins6saka4tsuka4t2vh3pa_ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e_t2f_izer5g1h_armacy6d1ilips5one2to_graphy6s4ysio5ics1tet2ures6d1n_g1k2oneer5zza4k1l_ace2y_station9umbing5s3m1n_c2ohl2ker3litie5rn2st3r_america6xi3ess3ime3o_d_uctions8f1gressive8mo2perties3y5tection8u_dential9s1t1ub2w_c2y2qa1pon3uebec3st5racing4dio4e_ad1lestate6tor2y4cipes5d_stone5umbrella9hab3ise_n3t2liance6n_t_als5pair3ort3ublican8st_aurant8view_s5xroth6ich_ardli6oh3l1o1p2o_cher3ks3deo3gers4om3s_vp3u_gby3hr2n2w_e2yukyu6sa_arland6fe_ty4kura4le1on3msclub4ung5ndvik_coromant12ofi4p1rl2s1ve2xo3b_i1s2c_a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e_arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x_y3fr2g1h_angrila6rp2w2ell3ia1ksha5oes2p_ping5uji3w_time7i_lk2na1gles5te3j1k_i_n2y_pe4l_ing4m_art3ile4n_cf3o_ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa_ce3ort2t3r_l2s1t_ada2ples4r1tebank4farm7c_group6ockholm6rage3e3ream4udio2y3yle4u_cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y_dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x_i3c_i2d_k2eam2ch_nology8l1masek5nnis4va3f1g1h_d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j_maxx4x2k_maxx5l1m_all4n1o_day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r_ade1ing4ining5vel_channel7ers_insurance16ust3v2t1ube2i1nes3shu4v_s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va_cations7na1guard7c1e_gas3ntures6risign5mögensberater2ung14sicherung10t2g1i_ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u_elos6wales2mart4ter4ng_gou5tch_es6eather_channel12bcam3er2site5d_ding5ibo2r3f1hoswho6ien2ki2lliamhill9n_dows4e1ners6me2olterskluwer11odside6rk_s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u_tube6t1un3za_ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5تصالات6رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत_म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里_大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * @template A\n * @template B\n * @param {A} target\n * @param {B} properties\n * @return {A & B}\n */\nconst assign = (target, properties) => {\n  for (const key in properties) {\n    target[key] = properties[key];\n  }\n  return target;\n};\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token) {\n  if (token === void 0) {\n    token = null;\n  }\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly) {\n    if (exactOnly === void 0) {\n      exactOnly = false;\n    }\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL$1 = 'NL'; // \\n\n\n// Opening/closing bracket classes\nconst OPENBRACE = 'OPENBRACE'; // {\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tWORD: WORD,\n\tUWORD: UWORD,\n\tLOCALHOST: LOCALHOST,\n\tTLD: TLD,\n\tUTLD: UTLD,\n\tSCHEME: SCHEME,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tNUM: NUM,\n\tWS: WS,\n\tNL: NL$1,\n\tOPENBRACE: OPENBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tCLOSEBRACE: CLOSEBRACE,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tCLOSEPAREN: CLOSEPAREN,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tHYPHEN: HYPHEN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tTILDE: TILDE,\n\tUNDERSCORE: UNDERSCORE,\n\tEMOJI: EMOJI$1,\n\tSYM: SYM\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tLETTER: LETTER,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tDIGIT: DIGIT,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\nconst NL = '\\n'; // New line character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes) {\n  if (customSchemes === void 0) {\n    customSchemes = [];\n  }\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, ASCII_LETTER, Word);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, LETTER, UWord);\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, NL, NL$1, {\n    [whitespace]: true\n  });\n  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10);\n      for (; popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else if (encoded[i] === '_') {\n      words.push(stack.join('')); // found a word, will be followed by another\n      i++;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender) {\n  if (defaultRender === void 0) {\n    defaultRender = null;\n  }\n  let o = assign({}, defaults);\n  if (opts) {\n    o = assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tdefaults: defaults,\n\tOptions: Options,\n\tassign: assign\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n  */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol) {\n    if (protocol === void 0) {\n      protocol = defaults.defaultProtocol;\n    }\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toFormattedHref(options);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = href;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme) {\n    if (scheme === void 0) {\n      scheme = defaults.defaultProtocol;\n    }\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMultiToken: MultiToken,\n\tBase: MultiToken,\n\tcreateTokenClass: createTokenClass,\n\tEmail: Email,\n\tText: Text,\n\tNl: Nl,\n\tUrl: Url\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1(_ref) {\n  let {\n    groups\n  } = _ref;\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port numner\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const UriPrefix = tt(Scheme, COLON); // e.g., 'mailto:' or 'http://'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  tt(SlashSchemeColonSlash, SLASH, UriPrefix);\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(UriPrefix, groups.domain, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n\n  // URL, followed by an opening bracket\n  const UrlOpenbrace = tt(Url$1, OPENBRACE); // URL followed by {\n  const UrlOpenbracket = tt(Url$1, OPENBRACKET); // URL followed by [\n  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET); // URL followed by <\n  const UrlOpenparen = tt(Url$1, OPENPAREN); // URL followed by (\n\n  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);\n  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);\n  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);\n  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);\n\n  // Closing bracket component. This character WILL be included in the URL\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparen, CLOSEPAREN, Url$1);\n  tt(UrlOpenbrace, CLOSEBRACE, Url$1);\n\n  // URL that beings with an opening bracket, followed by a symbols.\n  // Note that the final state can still be `UrlOpenbrace` (if the URL only\n  // has a single opening bracket for some reason).\n  const UrlOpenbraceQ = makeState(Url); // URL followed by { and some symbols that the URL can end it\n  const UrlOpenbracketQ = makeState(Url); // URL followed by [ and some symbols that the URL can end it\n  const UrlOpenanglebracketQ = makeState(Url); // URL followed by < and some symbols that the URL can end it\n  const UrlOpenparenQ = makeState(Url); // URL followed by ( and some symbols that the URL can end it\n  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);\n  const UrlOpenbraceSyms = makeState(); // UrlOpenbrace followed by some symbols it cannot end it\n  const UrlOpenbracketSyms = makeState(); // UrlOpenbracketQ followed by some symbols it cannot end it\n  const UrlOpenanglebracketSyms = makeState(); // UrlOpenanglebracketQ followed by some symbols it cannot end it\n  const UrlOpenparenSyms = makeState(); // UrlOpenparenQ followed by some symbols it cannot end it\n  ta(UrlOpenbrace, qsNonAccepting);\n  ta(UrlOpenbracket, qsNonAccepting);\n  ta(UrlOpenanglebracket, qsNonAccepting);\n  ta(UrlOpenparen, qsNonAccepting);\n\n  // URL that begins with an opening bracket, followed by some symbols\n  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);\n  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);\n  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);\n  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);\n  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);\n  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);\n  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);\n  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);\n\n  // Close brace/bracket to become regular URL\n  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);\n  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);\n  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);\n  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);\n  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL$1, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} protocol\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash) {\n  if (optionalSlashSlash === void 0) {\n    optionalSlashSlash = false;\n  }\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error('linkifyjs: incorrect scheme format.\\n 1. Must only contain digits, lowercase ASCII letters or \"-\"\\n 2. Cannot start or end with \"-\"\\n 3. \"-\" cannot repeat');\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n*/\nfunction find(str, type, opts) {\n  if (type === void 0) {\n    type = null;\n  }\n  if (opts === void 0) {\n    opts = null;\n  }\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type) {\n  if (type === void 0) {\n    type = null;\n  }\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, tokenize };\n","import { createTokenClass, registerPlugin } from 'linkifyjs';\n\nconst MentionToken = createTokenClass('mention', {\n  isLink: true,\n  toHref() {\n    return '/' + this.toString().slice(1);\n  }\n});\n\n/**\n * Mention parser plugin for linkify\n * @type {import('linkifyjs').Plugin}\n */\nfunction mention(_ref) {\n  let {\n    scanner,\n    parser\n  } = _ref;\n  const {\n    HYPHEN,\n    SLASH,\n    UNDERSCORE,\n    AT\n  } = scanner.tokens;\n  const {\n    domain\n  } = scanner.tokens.groups;\n\n  // @\n  const At = parser.start.tt(AT); // @\n\n  // Begin with hyphen (not mention unless contains other characters)\n  const AtHyphen = At.tt(HYPHEN);\n  AtHyphen.tt(HYPHEN, AtHyphen);\n\n  // Valid mention (not made up entirely of symbols)\n  const Mention = At.tt(UNDERSCORE, MentionToken);\n  At.ta(domain, Mention);\n  AtHyphen.tt(UNDERSCORE, Mention);\n  AtHyphen.ta(domain, Mention);\n\n  // More valid mentions\n  Mention.ta(domain, Mention);\n  Mention.tt(HYPHEN, Mention);\n  Mention.tt(UNDERSCORE, Mention);\n\n  // Mention with a divider\n  const MentionDivider = Mention.tt(SLASH);\n\n  // Once we get a word token, mentions can start up again\n  MentionDivider.ta(domain, Mention);\n  MentionDivider.tt(UNDERSCORE, Mention);\n  MentionDivider.tt(HYPHEN, Mention);\n}\n\nregisterPlugin('mention', mention);\n","import * as React from 'react';\nimport { Options, options, tokenize } from 'linkifyjs';\n\n/**\n * Given a string, converts to an array of valid React components\n * (which may include strings)\n * @param {string} str\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactNodeArray}\n */\nfunction stringToElements(str, opts, meta) {\n  const tokens = tokenize(str);\n  const elements = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.t === 'nl' && opts.get('nl2br')) {\n      const key = `__linkify-el-${meta.elementId++}`;\n      elements.push(React.createElement('br', {\n        key\n      }));\n    } else if (!token.isLink || !opts.check(token)) {\n      // Regular text\n      elements.push(token.toString());\n    } else {\n      let rendered = opts.render(token);\n      if (!('key' in rendered.props)) {\n        // Ensure generated element has unique key\n        const key = `__linkify-el-${meta.elementId++}`;\n        const props = options.assign({\n          key\n        }, rendered.props);\n        rendered = React.cloneElement(rendered, props);\n      }\n      elements.push(rendered);\n    }\n  }\n  return elements;\n}\n\n// Recursively linkify the contents of the given React Element instance\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {React.ReactElement<P, T>} element\n * @param {Options} opts\n * @param {{ [elementId: string]: number }} meta\n * @returns {React.ReactElement<P, T>}\n */\nfunction linkifyReactElement(element, opts, meta) {\n  if (React.Children.count(element.props.children) === 0) {\n    // No need to clone if the element had no children\n    return element;\n  }\n  const children = [];\n  React.Children.forEach(element.props.children, child => {\n    if (typeof child === 'string') {\n      // ensure that we always generate unique element IDs for keys\n      children.push.apply(children, stringToElements(child, opts, meta));\n    } else if (React.isValidElement(child)) {\n      if (typeof child.type === 'string' && opts.ignoreTags.indexOf(child.type.toUpperCase()) >= 0) {\n        // Don't linkify this element\n        children.push(child);\n      } else {\n        children.push(linkifyReactElement(child, opts, meta));\n      }\n    } else {\n      // Unknown element type, just push\n      children.push(child);\n    }\n  });\n\n  // Set a default unique key, copy over remaining props\n  const key = `__linkify-el-${meta.elementId++}`;\n  const newProps = options.assign({\n    key\n  }, element.props);\n  return React.cloneElement(element, newProps, children);\n}\n\n/**\n * @template P\n * @template {string | React.JSXElementConstructor<P>} T\n * @param {P & { as?: T, tagName?: T, tagName?: T, options?: import('linkifyjs').Opts, children?: React.ReactNode}} props\n * @returns {React.ReactElement<P, T>}\n */\nconst Linkify = props => {\n  // Copy over all non-linkify-specific props\n  let linkId = 0;\n  const defaultLinkRender = _ref => {\n    let {\n      tagName,\n      attributes,\n      content\n    } = _ref;\n    attributes.key = `__linkify-lnk-${linkId++}`;\n    if (attributes.class) {\n      attributes.className = attributes.class;\n      delete attributes.class;\n    }\n    return React.createElement(tagName, attributes, content);\n  };\n  const newProps = {\n    key: '__linkify-wrapper'\n  };\n  for (const prop in props) {\n    if (prop !== 'options' && prop !== 'as' && prop !== 'tagName' && prop !== 'children') {\n      newProps[prop] = props[prop];\n    }\n  }\n  const opts = new Options(props.options, defaultLinkRender);\n  const as = props.as || props.tagName || React.Fragment || 'span';\n  const children = props.children;\n  const element = React.createElement(as, newProps, children);\n  return linkifyReactElement(element, opts, {\n    elementId: 0\n  });\n};\n\nexport { Linkify as default };\n","import 'linkify-plugin-mention'\n\nimport { useTheme } from '@emotion/react'\nimport styled from '@emotion/styled'\nimport Linkify from 'linkify-react'\n\nimport { ExternalLink } from '../ExternalLink/ExternalLink'\nimport { InternalLink } from '../InternalLink/InternalLink'\n\nexport interface Props {\n  children?: React.ReactNode\n}\n\nexport const LinkifyText = (props: Props) => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const theme = useTheme() as any\n  const StyledExternalLink = styled(ExternalLink)`\n    color: ${theme.colors.grey}!important;\n    text-decoration: underline;\n  `\n  const StyledInternalLink = styled(InternalLink)`\n    color: ${theme.colors.grey};\n    font-weight: bold;\n  `\n\n  const renderExternalLink = ({ attributes = {} as any, content = '' }) => {\n    const { href, ...props } = attributes\n    return (\n      <StyledExternalLink href={href} {...props}>\n        {content}\n      </StyledExternalLink>\n    )\n  }\n  const renderInternalLink = ({ attributes = {} as any, content = '' }) => {\n    const { href, ...props } = attributes\n    return (\n      <StyledInternalLink to={`/u${href}`} {...props}>\n        {content}\n      </StyledInternalLink>\n    )\n  }\n\n  return (\n    <Linkify\n      options={{\n        render: {\n          mention: renderInternalLink,\n          url: renderExternalLink,\n        },\n      }}\n    >\n      {props.children}\n    </Linkify>\n  )\n}\n"],"names":["encodedTlds","encodedUtlds","assign","target","properties","key","numeric","ascii","alpha","asciinumeric","alphanumeric","domain","emoji","scheme","slashscheme","whitespace","registerGroup","name","groups","addToGroups","flags","k","group","flagsForToken","result","c","State","token","input","state","nextState","i","regex","exactOnly","inputs","next","regexp","len","t","templateState","allFlags","ta","tr","ts","tt","WORD","UWORD","LOCALHOST","TLD","UTLD","SCHEME","SLASH_SCHEME","NUM","WS","NL$1","OPENBRACE","OPENBRACKET","OPENANGLEBRACKET","OPENPAREN","CLOSEBRACE","CLOSEBRACKET","CLOSEANGLEBRACKET","CLOSEPAREN","AMPERSAND","APOSTROPHE","ASTERISK","AT","BACKSLASH","BACKTICK","CARET","COLON","COMMA","DOLLAR","DOT","EQUALS","EXCLAMATION","HYPHEN","PERCENT","PIPE","PLUS","POUND","QUERY","QUOTE","SEMI","SLASH","TILDE","UNDERSCORE","EMOJI$1","SYM","tk","ASCII_LETTER","LETTER","EMOJI","DIGIT","SPACE","NL","EMOJI_VARIATION","EMOJI_JOINER","tlds","utlds","init$2","customSchemes","Start","decodeTlds","Num","Word","UWord","Ws","Emoji","EmojiJoiner","wordjr","uwordjr","fastts","a","b","sch","run$1","start","str","iterable","stringToArray","charCount","tokens","cursor","charCursor","tokenLength","latestAccepting","sinceAccepts","charsSinceAccepts","index","first","second","char","defaultt","jr","encoded","words","stack","digits","popDigitCount","popCount","defaults","noop","Options","opts","defaultRender","o","ignoredTags","uppercaseIgnoredTags","ir","operator","isCallable","option","obj","val","options","MultiToken","value","truncate","formatted","protocol","href","tagName","content","attributes","className","rel","attrs","eventListeners","createTokenClass","type","props","Token","p","Email","Text","Nl","Url","makeState","arg","init$1","_ref","qsAccepting","qsNonAccepting","localpartAccepting","Localpart","Domain","Scheme","SlashScheme","LocalpartAt","LocalpartDot","EmailDomain","EmailDomainDot","Email$1","EmailDomainHyphen","EmailColon","DomainHyphen","DomainDot","DomainDotTld","DomainDotTldColon","DomainDotTldColonPort","Url$1","UrlNonaccept","UriPrefix","SlashSchemeColon","SlashSchemeColonSlash","UrlOpenbrace","UrlOpenbracket","UrlOpenanglebracket","UrlOpenparen","UrlOpenbraceQ","UrlOpenbracketQ","UrlOpenanglebracketQ","UrlOpenparenQ","UrlOpenbraceSyms","UrlOpenbracketSyms","UrlOpenanglebracketSyms","UrlOpenparenSyms","run","multis","textTokens","secondState","multiLength","initMultiToken","Multi","subtokens","startIdx","endIdx","warn","warnAdvice","INIT","registerPlugin","plugin","init","tokenize","MentionToken","mention","scanner","parser","At","AtHyphen","Mention","MentionDivider","stringToElements","meta","elements","React.createElement","rendered","React.cloneElement","linkifyReactElement","element","React.Children","children","child","React.isValidElement","newProps","Linkify","linkId","defaultLinkRender","prop","as","React.Fragment","LinkifyText","theme","useTheme","StyledExternalLink","styled","ExternalLink","StyledInternalLink","InternalLink","jsx","props2"],"mappings":"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","x_google_ignoreList":[0,1,2]}