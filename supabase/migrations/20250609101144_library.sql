create table "public"."project_steps" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "project_id" bigint not null,
    "title" text not null,
    "description" text not null,
    "images" json,
    "video_url" text,
    "order" smallint null,
    "tenant_id" text not null
);


alter table "public"."project_steps" enable row level security;

create table "public"."projects" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "modified_at" timestamp with time zone,
    "title" text not null,
    "slug" text not null,
    "previous_slugs" text[],
    "description" text not null,
    "created_by" bigint,
    "deleted" boolean,
    "category" bigint,
    "difficulty_level" text,
    "cover_image" json,
    "file_link" text,
    "files" json[],
    "tags" text[],
    "is_draft" boolean,
    "time" text,
    "file_download_count" integer,
    "moderation" text,
    "moderation_feedback" text,
    "tenant_id" text not null,
    "fts" tsvector,
    "total_views" bigint,
    "comment_count" integer,
    "legacy_id" text
);


alter table "public"."projects" enable row level security;

CREATE UNIQUE INDEX project_steps_pkey ON public.project_steps USING btree (id);

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE UNIQUE INDEX projects_slug_key ON public.projects USING btree (slug, tenant_id);

CREATE UNIQUE INDEX projects_title_key ON public.projects USING btree (title, tenant_id);

alter table "public"."project_steps" add constraint "project_steps_pkey" PRIMARY KEY using index "project_steps_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."project_steps" add constraint "project_steps_project_id_fkey" FOREIGN KEY (project_id) REFERENCES projects(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."project_steps" validate constraint "project_steps_project_id_fkey";

alter table "public"."projects" add constraint "projects_category_id_fkey" FOREIGN KEY (category) REFERENCES categories(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."projects" validate constraint "projects_category_id_fkey";

alter table "public"."projects" add constraint "projects_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."projects" validate constraint "projects_created_by_fkey";

alter table "public"."projects" add constraint "projects_slug_key" UNIQUE using index "projects_slug_key";

alter table "public"."projects" add constraint "projects_title_key" UNIQUE using index "projects_title_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.combined_project_search_fields(project_id_param bigint)
 RETURNS text
 LANGUAGE sql
AS $function$
  SELECT
    (SELECT p.title || ' ' || p.description FROM projects p WHERE p.id = project_id_param) || ' ' ||
    COALESCE(string_agg(ps.title || ' ' || ps.description, ' '), '')
  FROM project_steps ps
  WHERE ps.project_id = project_id_param;
$function$
;

CREATE OR REPLACE FUNCTION public.get_projects(search_query text DEFAULT NULL::text, category_id bigint DEFAULT NULL::bigint, sort_by text DEFAULT 'Newest'::text, limit_val integer DEFAULT 12, offset_val integer DEFAULT 0)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, created_by bigint, modified_at timestamp with time zone, description text, slug text, cover_image json, category json, tags text[], title text, moderation text, total_views bigint, author json, comment_count integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
  ts_query tsquery;
BEGIN
    -- Parse search query once if provided
    IF search_query IS NOT NULL THEN
      ts_query := to_tsquery('english', search_query);
    END IF;

    RETURN QUERY
    SELECT
        p.id,
        p.created_at,
        p.created_by,
        p.modified_at,
        p.description,
        p.slug,
        p.cover_image,
        (SELECT json_build_object('id', c.id, 'name', c.name)
         FROM categories c
         WHERE c.id = p.category) AS category,
        p.tags,
        p.title,
        p.moderation,
        p.total_views,
        (SELECT json_build_object(
            'id', prof.id,
            'display_name', prof.display_name,
            'username', prof.username,
            'is_verified', prof.is_verified,
            'country', prof.country
        )
         FROM profiles prof
         WHERE prof.id = p.created_by) AS author,
        p.comment_count
    FROM projects p
    WHERE
        (search_query IS NULL OR p.fts @@ ts_query) AND
        (category_id IS NULL OR p.category = category_id) AND
        (p.is_draft IS NULL OR p.is_draft = FALSE) AND
        (p.deleted IS NULL OR p.deleted = FALSE)
    ORDER BY
        -- Add relevance ranking when search query is provided
        CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(r.fts, ts_query) END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'Newest' THEN extract(epoch from p.created_at)
            WHEN sort_by = 'LatestUpdated' THEN extract(epoch from p.modified_at)
            WHEN sort_by = 'MostComments' THEN p.comment_count
            WHEN sort_by = 'MostDownloads' THEN p.file_download_count
            WHEN sort_by = 'MostUseful' THEN
                (SELECT COALESCE(COUNT(uv.id), 0)
                 FROM useful_votes uv
                 WHERE uv.content_id = p.id AND uv.content_type = 'projects')
            ELSE 0
        END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'LeastComments' THEN p.comment_count
        END ASC NULLS LAST,
        p.created_at DESC
    LIMIT limit_val OFFSET offset_val;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_projects_count(search_query text DEFAULT NULL::text, category_id integer DEFAULT NULL::integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM projects p
    WHERE
      (search_query IS NULL OR p.fts @@ to_tsquery('english', search_query)) AND
      (category_id IS NULL OR p.category = category_id) AND
      (p.is_draft IS NULL OR p.is_draft = FALSE) AND
      (p.deleted IS NULL OR p.deleted = FALSE)
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_project_tsvector()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_TABLE_NAME = 'project_steps' THEN
    UPDATE projects
    SET fts = to_tsvector('english', public.combined_project_search_fields(NEW.project_id))
    WHERE id = NEW.project_id;
  ELSEIF TG_TABLE_NAME = 'projects' THEN
    UPDATE projects
    SET fts = to_tsvector('english', public.combined_project_search_fields(NEW.id))
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_projects(username_param text)
 RETURNS TABLE(id bigint, title text, slug text, total_useful bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    pr.id,
    pr.title,
    pr.slug,
    COALESCE(COUNT(uv.id), 0)::BIGINT AS total_useful
  FROM projects pr
  INNER JOIN profiles p ON p.id = pr.created_by
  LEFT JOIN useful_votes uv ON uv.content_id = pr.id AND uv.content_type = 'projects'
  WHERE p.username = username_param
  AND (pr.deleted IS NULL OR pr.deleted = FALSE)
  GROUP BY pr.id, pr.title, pr.slug;
END;
$function$
;

grant delete on table "public"."project_steps" to "anon";

grant insert on table "public"."project_steps" to "anon";

grant references on table "public"."project_steps" to "anon";

grant select on table "public"."project_steps" to "anon";

grant trigger on table "public"."project_steps" to "anon";

grant truncate on table "public"."project_steps" to "anon";

grant update on table "public"."project_steps" to "anon";

grant delete on table "public"."project_steps" to "authenticated";

grant insert on table "public"."project_steps" to "authenticated";

grant references on table "public"."project_steps" to "authenticated";

grant select on table "public"."project_steps" to "authenticated";

grant trigger on table "public"."project_steps" to "authenticated";

grant truncate on table "public"."project_steps" to "authenticated";

grant update on table "public"."project_steps" to "authenticated";

grant delete on table "public"."project_steps" to "service_role";

grant insert on table "public"."project_steps" to "service_role";

grant references on table "public"."project_steps" to "service_role";

grant select on table "public"."project_steps" to "service_role";

grant trigger on table "public"."project_steps" to "service_role";

grant truncate on table "public"."project_steps" to "service_role";

grant update on table "public"."project_steps" to "service_role";

grant delete on table "public"."projects" to "anon";

grant insert on table "public"."projects" to "anon";

grant references on table "public"."projects" to "anon";

grant select on table "public"."projects" to "anon";

grant trigger on table "public"."projects" to "anon";

grant truncate on table "public"."projects" to "anon";

grant update on table "public"."projects" to "anon";

grant delete on table "public"."projects" to "authenticated";

grant insert on table "public"."projects" to "authenticated";

grant references on table "public"."projects" to "authenticated";

grant select on table "public"."projects" to "authenticated";

grant trigger on table "public"."projects" to "authenticated";

grant truncate on table "public"."projects" to "authenticated";

grant update on table "public"."projects" to "authenticated";

grant delete on table "public"."projects" to "service_role";

grant insert on table "public"."projects" to "service_role";

grant references on table "public"."projects" to "service_role";

grant select on table "public"."projects" to "service_role";

grant trigger on table "public"."projects" to "service_role";

grant truncate on table "public"."projects" to "service_role";

grant update on table "public"."projects" to "service_role";

create policy "tenant_isolation"
on "public"."project_steps"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


create policy "tenant_isolation"
on "public"."projects"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


CREATE TRIGGER project_step_trigger AFTER INSERT OR DELETE OR UPDATE OF title, description ON public.project_steps FOR EACH ROW EXECUTE FUNCTION update_project_tsvector();

CREATE TRIGGER project_text_trigger AFTER INSERT OR UPDATE OF title, description ON public.projects FOR EACH ROW EXECUTE FUNCTION update_project_tsvector();


