create table "public"."map_pins" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_id" bigint not null,
    "country" text not null,
    "country_code" text not null,
    "administrative" text,
    "post_code" text,
    "lat" text not null,
    "lng" text not null,
    "moderation" text not null,
    "tenant_id" text not null,
    "moderation_feedback" text,
    "name" text
);


alter table "public"."map_pins" enable row level security;

create table "public"."profile_tags" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "name" text not null,
    "tenant_id" text not null,
    "profile_type" text
);

alter table "public"."profile_tags" enable row level security;

create table "public"."profile_tags_relations" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "profile_id" bigint not null,
    "profile_tag_id" bigint not null,
    "tenant_id" text not null
);

create table "public"."profile_badges" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "display_name" text not null,
    "image_url" text not null,
    "action_url" text,
    "tenant_id" text not null
);

alter table "public"."profile_badges" enable row level security;

create table "public"."profile_badges_relations" (
    "id" bigint generated by default as identity not null,
    "profile_id" bigint not null,
    "profile_badge_id" bigint not null,
    "tenant_id" text not null
);

alter table "public"."profile_tags_relations" enable row level security;

create table "public"."profile_types" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "display_name" text not null,
    "order" smallint not null,
    "image_url" text not null,
    "small_image_url" text not null,
    "description" text not null,
    "map_pin_name" text not null,
    "is_space" boolean not null,
    "tenant_id" text not null
);

alter table "public"."profile_types" enable row level security;

create table "public"."map_settings" (
    "id" bigint generated by default as identity not null,
    "default_type_filters" text[] null,
    "setting_filters" text[] not null,
    "tenant_id" text not null
);

alter table "public"."map_settings" enable row level security;

alter table "public"."profiles" drop column "links";

alter table "public"."profiles" drop column "notification_settings";

alter table "public"."profiles" drop column "notifications";

alter table "public"."profiles" drop column "tags";

alter table "public"."profiles" drop column "total_useful";

alter table "public"."profiles" drop column "location";

alter table "public"."profiles" drop column "is_verified";

alter table "public"."profiles" add column "cover_images" json[];

alter table "public"."profiles" add column "last_active" timestamp with time zone;

alter table "public"."profiles" add column "photo" json;

alter table "public"."profiles" add column "visitor_policy" json;

alter table "public"."profiles" add column "website" text;

alter table "public"."profiles" add column "profile_type" bigint;

CREATE INDEX map_pins_lat_lng_idx ON public.map_pins USING btree (lat, lng);

CREATE UNIQUE INDEX map_pins_pkey ON public.map_pins USING btree (id);

CREATE INDEX map_pins_user_id_idx ON public.map_pins USING btree (profile_id);

CREATE UNIQUE INDEX profile_tags_pkey ON public.profile_tags USING btree (id);

CREATE UNIQUE INDEX profile_tags_relations_pkey ON public.profile_tags_relations USING btree (id);

CREATE UNIQUE INDEX profile_badges_pkey ON public.profile_badges USING btree (id);

CREATE UNIQUE INDEX profile_badges_relations_pkey ON public.profile_badges_relations USING btree (id);

CREATE UNIQUE INDEX profile_types_pkey ON public.profile_types USING btree (id);
alter table "public"."profile_types" add constraint "profile_types_pkey" PRIMARY KEY using index "profile_types_pkey";

CREATE UNIQUE INDEX map_settings_pkey ON public.map_settings USING btree (id);
alter table "public"."map_settings" add constraint "map_settings_pkey" PRIMARY KEY using index "map_settings_pkey";

alter table "public"."profile_badges_relations" enable row level security;

alter table "public"."map_pins" add constraint "map_pins_pkey" PRIMARY KEY using index "map_pins_pkey";

alter table "public"."profile_tags" add constraint "profile_tags_pkey" PRIMARY KEY using index "profile_tags_pkey";

alter table "public"."profile_tags_relations" add constraint "profile_tags_relations_pkey" PRIMARY KEY using index "profile_tags_relations_pkey";

alter table "public"."profile_badges" add constraint "profile_badges_pkey" PRIMARY KEY using index "profile_badges_pkey";

alter table "public"."profile_badges_relations" add constraint "profile_badges_relations_pkey" PRIMARY KEY using index "profile_badges_relations_pkey";

alter table "public"."map_pins" add constraint "map_pins_user_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."map_pins" validate constraint "map_pins_user_id_fkey";

alter table "public"."profile_tags_relations" add constraint "profile_tags_relations_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile_tags_relations" validate constraint "profile_tags_relations_profile_id_fkey";

alter table "public"."profile_tags_relations" add constraint "profile_tags_relations_profile_tag_id_fkey" FOREIGN KEY (profile_tag_id) REFERENCES profile_tags(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile_tags_relations" validate constraint "profile_tags_relations_profile_tag_id_fkey";

alter table "public"."profile_badges_relations" add constraint "profile_badges_relations_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile_badges_relations" validate constraint "profile_badges_relations_profile_id_fkey";

alter table "public"."profile_badges_relations" add constraint "profile_badges_relations_profile_badge_id_fkey" FOREIGN KEY (profile_badge_id) REFERENCES profile_badges(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile_badges_relations" validate constraint "profile_badges_relations_profile_badge_id_fkey";

alter table "public"."profiles" add constraint "profiles_profile_type_fkey" FOREIGN KEY (profile_type) REFERENCES profile_types(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."profiles" validate constraint "profiles_profile_type_fkey";


set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_author_vote_counts(author_id bigint)
 RETURNS TABLE(content_type text, vote_count bigint)
 LANGUAGE sql
 STABLE
AS $function$
    SELECT 
        uv.content_type,
        COUNT(*) as vote_count
    FROM useful_votes uv
    WHERE (uv.content_type = 'questions' AND EXISTS (
        SELECT 1 FROM questions q WHERE q.id = uv.content_id AND q.created_by = author_id
    ))
    OR (uv.content_type = 'projects' AND EXISTS (
        SELECT 1 FROM projects p WHERE p.id = uv.content_id AND p.created_by = author_id
    ))
    OR (uv.content_type = 'news' AND EXISTS (
        SELECT 1 FROM news n WHERE n.id = uv.content_id AND n.created_by = author_id
    ))
    OR (uv.content_type = 'research' AND EXISTS (
        SELECT 1 FROM research r WHERE r.id = uv.content_id AND r.created_by = author_id
    ))
    GROUP BY uv.content_type
    ORDER BY vote_count DESC;
$function$
;

grant delete on table "public"."map_pins" to "anon";

grant insert on table "public"."map_pins" to "anon";

grant references on table "public"."map_pins" to "anon";

grant select on table "public"."map_pins" to "anon";

grant trigger on table "public"."map_pins" to "anon";

grant truncate on table "public"."map_pins" to "anon";

grant update on table "public"."map_pins" to "anon";

grant delete on table "public"."map_pins" to "authenticated";

grant insert on table "public"."map_pins" to "authenticated";

grant references on table "public"."map_pins" to "authenticated";

grant select on table "public"."map_pins" to "authenticated";

grant trigger on table "public"."map_pins" to "authenticated";

grant truncate on table "public"."map_pins" to "authenticated";

grant update on table "public"."map_pins" to "authenticated";

grant delete on table "public"."map_pins" to "service_role";

grant insert on table "public"."map_pins" to "service_role";

grant references on table "public"."map_pins" to "service_role";

grant select on table "public"."map_pins" to "service_role";

grant trigger on table "public"."map_pins" to "service_role";

grant truncate on table "public"."map_pins" to "service_role";

grant update on table "public"."map_pins" to "service_role";

grant delete on table "public"."profile_tags" to "anon";

grant insert on table "public"."profile_tags" to "anon";

grant references on table "public"."profile_tags" to "anon";

grant select on table "public"."profile_tags" to "anon";

grant trigger on table "public"."profile_tags" to "anon";

grant truncate on table "public"."profile_tags" to "anon";

grant update on table "public"."profile_tags" to "anon";

grant delete on table "public"."profile_tags" to "authenticated";

grant insert on table "public"."profile_tags" to "authenticated";

grant references on table "public"."profile_tags" to "authenticated";

grant select on table "public"."profile_tags" to "authenticated";

grant trigger on table "public"."profile_tags" to "authenticated";

grant truncate on table "public"."profile_tags" to "authenticated";

grant update on table "public"."profile_tags" to "authenticated";

grant delete on table "public"."profile_tags" to "service_role";

grant insert on table "public"."profile_tags" to "service_role";

grant references on table "public"."profile_tags" to "service_role";

grant select on table "public"."profile_tags" to "service_role";

grant trigger on table "public"."profile_tags" to "service_role";

grant truncate on table "public"."profile_tags" to "service_role";

grant update on table "public"."profile_tags" to "service_role";

grant delete on table "public"."profile_tags_relations" to "anon";

grant insert on table "public"."profile_tags_relations" to "anon";

grant references on table "public"."profile_tags_relations" to "anon";

grant select on table "public"."profile_tags_relations" to "anon";

grant trigger on table "public"."profile_tags_relations" to "anon";

grant truncate on table "public"."profile_tags_relations" to "anon";

grant update on table "public"."profile_tags_relations" to "anon";

grant delete on table "public"."profile_tags_relations" to "authenticated";

grant insert on table "public"."profile_tags_relations" to "authenticated";

grant references on table "public"."profile_tags_relations" to "authenticated";

grant select on table "public"."profile_tags_relations" to "authenticated";

grant trigger on table "public"."profile_tags_relations" to "authenticated";

grant truncate on table "public"."profile_tags_relations" to "authenticated";

grant update on table "public"."profile_tags_relations" to "authenticated";

grant delete on table "public"."profile_tags_relations" to "service_role";

grant insert on table "public"."profile_tags_relations" to "service_role";

grant references on table "public"."profile_tags_relations" to "service_role";

grant select on table "public"."profile_tags_relations" to "service_role";

grant trigger on table "public"."profile_tags_relations" to "service_role";

grant truncate on table "public"."profile_tags_relations" to "service_role";

grant update on table "public"."profile_badges_relations" to "service_role";

grant delete on table "public"."profile_badges" to "anon";

grant insert on table "public"."profile_badges" to "anon";

grant references on table "public"."profile_badges" to "anon";

grant select on table "public"."profile_badges" to "anon";

grant trigger on table "public"."profile_badges" to "anon";

grant truncate on table "public"."profile_badges" to "anon";

grant update on table "public"."profile_badges" to "anon";

grant delete on table "public"."profile_badges" to "authenticated";

grant insert on table "public"."profile_badges" to "authenticated";

grant references on table "public"."profile_badges" to "authenticated";

grant select on table "public"."profile_badges" to "authenticated";

grant trigger on table "public"."profile_badges" to "authenticated";

grant truncate on table "public"."profile_badges" to "authenticated";

grant update on table "public"."profile_badges" to "authenticated";

grant delete on table "public"."profile_badges" to "service_role";

grant insert on table "public"."profile_badges" to "service_role";

grant references on table "public"."profile_badges" to "service_role";

grant select on table "public"."profile_badges" to "service_role";

grant trigger on table "public"."profile_badges" to "service_role";

grant truncate on table "public"."profile_badges" to "service_role";

grant update on table "public"."profile_badges" to "service_role";

grant delete on table "public"."profile_badges_relations" to "anon";

grant insert on table "public"."profile_badges_relations" to "anon";

grant references on table "public"."profile_badges_relations" to "anon";

grant select on table "public"."profile_badges_relations" to "anon";

grant trigger on table "public"."profile_badges_relations" to "anon";

grant truncate on table "public"."profile_badges_relations" to "anon";

grant update on table "public"."profile_badges_relations" to "anon";

grant delete on table "public"."profile_badges_relations" to "authenticated";

grant insert on table "public"."profile_badges_relations" to "authenticated";

grant references on table "public"."profile_badges_relations" to "authenticated";

grant select on table "public"."profile_badges_relations" to "authenticated";

grant trigger on table "public"."profile_badges_relations" to "authenticated";

grant truncate on table "public"."profile_badges_relations" to "authenticated";

grant update on table "public"."profile_badges_relations" to "authenticated";

grant delete on table "public"."profile_badges_relations" to "service_role";

grant insert on table "public"."profile_badges_relations" to "service_role";

grant references on table "public"."profile_badges_relations" to "service_role";

grant select on table "public"."profile_badges_relations" to "service_role";

grant trigger on table "public"."profile_badges_relations" to "service_role";

grant truncate on table "public"."profile_badges_relations" to "service_role";

grant update on table "public"."profile_badges_relations" to "service_role";

grant delete on table "public"."profile_types" to "anon";

grant insert on table "public"."profile_types" to "anon";

grant references on table "public"."profile_types" to "anon";

grant select on table "public"."profile_types" to "anon";

grant trigger on table "public"."profile_types" to "anon";

grant truncate on table "public"."profile_types" to "anon";

grant update on table "public"."profile_types" to "anon";

grant delete on table "public"."profile_types" to "authenticated";

grant insert on table "public"."profile_types" to "authenticated";

grant references on table "public"."profile_types" to "authenticated";

grant select on table "public"."profile_types" to "authenticated";

grant trigger on table "public"."profile_types" to "authenticated";

grant truncate on table "public"."profile_types" to "authenticated";

grant update on table "public"."profile_types" to "authenticated";

grant delete on table "public"."profile_types" to "service_role";

grant insert on table "public"."profile_types" to "service_role";

grant references on table "public"."profile_types" to "service_role";

grant select on table "public"."profile_types" to "service_role";

grant trigger on table "public"."profile_types" to "service_role";

grant truncate on table "public"."profile_types" to "service_role";

grant update on table "public"."profile_types" to "service_role";

-- Missing grants for map_settings table
grant delete on table "public"."map_settings" to "anon";

grant insert on table "public"."map_settings" to "anon";

grant references on table "public"."map_settings" to "anon";

grant select on table "public"."map_settings" to "anon";

grant trigger on table "public"."map_settings" to "anon";

grant truncate on table "public"."map_settings" to "anon";

grant update on table "public"."map_settings" to "anon";

grant delete on table "public"."map_settings" to "authenticated";

grant insert on table "public"."map_settings" to "authenticated";

grant references on table "public"."map_settings" to "authenticated";

grant select on table "public"."map_settings" to "authenticated";

grant trigger on table "public"."map_settings" to "authenticated";

grant truncate on table "public"."map_settings" to "authenticated";

grant update on table "public"."map_settings" to "authenticated";

grant delete on table "public"."map_settings" to "service_role";

grant insert on table "public"."map_settings" to "service_role";

grant references on table "public"."map_settings" to "service_role";

grant select on table "public"."map_settings" to "service_role";

grant trigger on table "public"."map_settings" to "service_role";

grant truncate on table "public"."map_settings" to "service_role";

grant update on table "public"."map_settings" to "service_role";

create policy "tenant_isolation"
on "public"."map_pins"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


create policy "tenant_isolation"
on "public"."profile_tags"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


create policy "tenant_isolation"
on "public"."profile_tags_relations"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));

create policy "tenant_isolation"
on "public"."profile_badges"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


create policy "tenant_isolation"
on "public"."profile_badges_relations"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));

create policy "tenant_isolation"
on "public"."profile_types"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));

create policy "tenant_isolation"
on "public"."map_settings"
as permissive
for all
to public
using ((tenant_id = ((current_setting('request.headers'::text, true))::json ->> 'x-tenant-id'::text)));


alter table "public"."profiles" drop column "photo_url";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_projects(search_query text DEFAULT NULL::text, category_id bigint DEFAULT NULL::bigint, sort_by text DEFAULT 'Newest'::text, limit_val integer DEFAULT 12, offset_val integer DEFAULT 0, current_username text DEFAULT NULL::text)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, created_by bigint, modified_at timestamp with time zone, description text, slug text, cover_image json, category json, tags text[], title text, moderation text, total_views bigint, author json, comment_count integer)
 LANGUAGE plpgsql
AS $function$DECLARE
    ts_query tsquery;
BEGIN
    -- Parse search query once if provided
    IF search_query IS NOT NULL THEN
        ts_query := to_tsquery('english', search_query);
    END IF;
    
    RETURN QUERY
    SELECT
        p.id,
        p.created_at,
        p.created_by,
        p.modified_at,
        p.description,
        p.slug,
        p.cover_image,
        (SELECT json_build_object('id', c.id, 'name', c.name)
         FROM categories c
         WHERE c.id = p.category) AS category,
        p.tags,
        p.title,
        p.moderation,
        p.total_views,
        (SELECT json_build_object(
            'id', prof.id,
            'display_name', prof.display_name,
            'username', prof.username,
            'country', prof.country,
            'badges', COALESCE(
                (SELECT json_agg(
                    json_build_object(
                        'id', pb.id,
                        'name', pb.name,
                        'display_name', pb.display_name,
                        'image_url', pb.image_url,
                        'action_url', pb.action_url
                    )
                )
                FROM profile_badges_relations pbr
                JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
                WHERE pbr.profile_id = prof.id),
                '[]'::json
            )
        ) FROM profiles prof WHERE prof.id = p.created_by) AS author,
        p.comment_count
    FROM projects p
    JOIN profiles prof ON prof.id = p.created_by  -- Add explicit JOIN
    WHERE
        (search_query IS NULL OR
         p.fts @@ ts_query OR
         prof.username ILIKE '%' || search_query || '%'
        ) AND
        (category_id IS NULL OR p.category = category_id) AND
        (p.is_draft IS NULL OR p.is_draft = FALSE) AND
        (p.deleted IS NULL OR p.deleted = FALSE) AND
        (p.moderation = 'accepted' OR prof.username = current_username)
    ORDER BY
        -- Add relevance ranking when search query is provided
        CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(p.fts, ts_query) END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'Newest' THEN extract(epoch from p.created_at)
            WHEN sort_by = 'LatestUpdated' THEN extract(epoch from p.modified_at)
            WHEN sort_by = 'MostComments' THEN p.comment_count
            WHEN sort_by = 'MostDownloads' THEN p.file_download_count
            WHEN sort_by = 'MostUseful' THEN
                (SELECT COALESCE(COUNT(uv.id), 0)
                 FROM useful_votes uv
                 WHERE uv.content_id = p.id AND uv.content_type = 'projects')
            ELSE 0
        END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'LeastComments' THEN p.comment_count
        END ASC NULLS LAST,
        p.created_at DESC
    LIMIT limit_val OFFSET offset_val;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_research(search_query text DEFAULT NULL::text, category_id bigint DEFAULT NULL::bigint, research_status research_status DEFAULT NULL::research_status, sort_by text DEFAULT 'Newest'::text, limit_val integer DEFAULT 10, offset_val integer DEFAULT 0)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, created_by bigint, modified_at timestamp with time zone, description text, slug text, image json, status research_status, category json, tags text[], title text, total_views integer, author json, update_count bigint, comment_count bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  ts_query tsquery;
BEGIN
  -- Parse the search query once if provided
  IF search_query IS NOT NULL THEN
    ts_query := to_tsquery('english', search_query);
  END IF;
 
  RETURN QUERY
  SELECT
    r.id,
    r.created_at,
    r.created_by,
    GREATEST(
      r.modified_at,
      COALESCE(
        (SELECT MAX(ru.modified_at) FROM research_updates ru
         WHERE ru.research_id = r.id
           AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
           AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
        r.modified_at
      )
    ) AS modified_at,
    r.description,
    r.slug,
    r.image,
    r.status,
    (SELECT json_build_object('id', c.id, 'name', c.name) FROM categories c WHERE c.id = r.category) AS category,
    r.tags,
    r.title,
    r.total_views,
    (SELECT json_build_object(
      'id', p.id,
      'display_name', p.display_name,
      'username', p.username,
      'country', p.country,
      'badges', COALESCE(
        (SELECT json_agg(
          json_build_object(
            'id', pb.id,
            'name', pb.name,
            'display_name', pb.display_name,
            'image_url', pb.image_url,
            'action_url', pb.action_url
          )
        )
        FROM profile_badges_relations pbr
        JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
        WHERE pbr.profile_id = p.id),
        '[]'::json
      )
    ) FROM profiles p WHERE p.id = r.created_by) AS author,
    (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS update_count,
    (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS comment_count
  FROM research r
  WHERE
    (search_query IS NULL OR r.fts @@ ts_query) AND
    (category_id IS NULL OR r.category = category_id) AND
    (research_status IS NULL OR r.status = research_status) AND
    (r.is_draft IS NULL OR r.is_draft = FALSE) AND
    (r.deleted IS NULL OR r.deleted = FALSE)
  ORDER BY
    -- Add relevance ranking when search query is provided
    CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(r.fts, ts_query) END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'Newest' THEN extract(epoch from r.created_at)
      WHEN sort_by = 'LatestUpdated' THEN extract(epoch from
        GREATEST(
          r.modified_at,
          COALESCE(
            (SELECT MAX(ru.modified_at) FROM research_updates ru
             WHERE ru.research_id = r.id
               AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
               AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
            r.modified_at
          )
        )
      )
      WHEN sort_by = 'MostComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      WHEN sort_by = 'MostUseful' THEN
        (SELECT COALESCE(COUNT(uv.id), 0) FROM useful_votes uv WHERE uv.content_id = r.id AND uv.content_type = 'research')
      WHEN sort_by = 'MostUpdates' THEN
        (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      ELSE 0
    END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'LeastComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
    END ASC NULLS LAST,
    r.created_at DESC
  LIMIT limit_val OFFSET offset_val;
END;
$function$
;

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_projects(search_query text DEFAULT NULL::text, category_id bigint DEFAULT NULL::bigint, sort_by text DEFAULT 'Newest'::text, limit_val integer DEFAULT 12, offset_val integer DEFAULT 0, current_username text DEFAULT NULL::text)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, created_by bigint, modified_at timestamp with time zone, description text, slug text, cover_image json, category json, tags text[], title text, moderation text, total_views bigint, author json, comment_count integer)
 LANGUAGE plpgsql
AS $function$DECLARE
    ts_query tsquery;
BEGIN
    -- Parse search query once if provided
    IF search_query IS NOT NULL THEN
        ts_query := to_tsquery('english', search_query);
    END IF;
    
    RETURN QUERY
    SELECT
        p.id,
        p.created_at,
        p.created_by,
        p.modified_at,
        p.description,
        p.slug,
        p.cover_image,
        (SELECT json_build_object('id', c.id, 'name', c.name)
         FROM categories c
         WHERE c.id = p.category) AS category,
        p.tags,
        p.title,
        p.moderation,
        p.total_views,
        (SELECT json_build_object(
            'id', prof.id,
            'display_name', prof.display_name,
            'username', prof.username,
            'country', prof.country,
            'badges', COALESCE(
                (SELECT json_agg(
                    json_build_object(
                        'id', pb.id,
                        'name', pb.name,
                        'display_name', pb.display_name,
                        'image_url', pb.image_url,
                        'action_url', pb.action_url
                    )
                )
                FROM profile_badges_relations pbr
                JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
                WHERE pbr.profile_id = prof.id),
                '[]'::json
            )
        ) FROM profiles prof WHERE prof.id = p.created_by) AS author,
        p.comment_count
    FROM projects p
    JOIN profiles prof ON prof.id = p.created_by  -- Add explicit JOIN
    WHERE
        (search_query IS NULL OR
         p.fts @@ ts_query OR
         prof.username ILIKE '%' || search_query || '%'
        ) AND
        (category_id IS NULL OR p.category = category_id) AND
        (p.is_draft IS NULL OR p.is_draft = FALSE) AND
        (p.deleted IS NULL OR p.deleted = FALSE) AND
        (p.moderation = 'accepted' OR prof.username = current_username)
    ORDER BY
        -- Add relevance ranking when search query is provided
        CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(p.fts, ts_query) END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'Newest' THEN extract(epoch from p.created_at)
            WHEN sort_by = 'LatestUpdated' THEN extract(epoch from p.modified_at)
            WHEN sort_by = 'MostComments' THEN p.comment_count
            WHEN sort_by = 'MostDownloads' THEN p.file_download_count
            WHEN sort_by = 'MostUseful' THEN
                (SELECT COALESCE(COUNT(uv.id), 0)
                 FROM useful_votes uv
                 WHERE uv.content_id = p.id AND uv.content_type = 'projects')
            ELSE 0
        END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'LeastComments' THEN p.comment_count
        END ASC NULLS LAST,
        p.created_at DESC
    LIMIT limit_val OFFSET offset_val;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_research(search_query text DEFAULT NULL::text, category_id bigint DEFAULT NULL::bigint, research_status research_status DEFAULT NULL::research_status, sort_by text DEFAULT 'Newest'::text, limit_val integer DEFAULT 10, offset_val integer DEFAULT 0)
 RETURNS TABLE(id bigint, created_at timestamp with time zone, created_by bigint, modified_at timestamp with time zone, description text, slug text, image json, status research_status, category json, tags text[], title text, total_views integer, author json, update_count bigint, comment_count bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  ts_query tsquery;
BEGIN
  -- Parse the search query once if provided
  IF search_query IS NOT NULL THEN
    ts_query := to_tsquery('english', search_query);
  END IF;
 
  RETURN QUERY
  SELECT
    r.id,
    r.created_at,
    r.created_by,
    GREATEST(
      r.modified_at,
      COALESCE(
        (SELECT MAX(ru.modified_at) FROM research_updates ru
         WHERE ru.research_id = r.id
           AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
           AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
        r.modified_at
      )
    ) AS modified_at,
    r.description,
    r.slug,
    r.image,
    r.status,
    (SELECT json_build_object('id', c.id, 'name', c.name) FROM categories c WHERE c.id = r.category) AS category,
    r.tags,
    r.title,
    r.total_views,
    (SELECT json_build_object(
      'id', p.id,
      'display_name', p.display_name,
      'username', p.username,
      'country', p.country,
      'badges', COALESCE(
        (SELECT json_agg(
          json_build_object(
            'id', pb.id,
            'name', pb.name,
            'display_name', pb.display_name,
            'image_url', pb.image_url,
            'action_url', pb.action_url
          )
        )
        FROM profile_badges_relations pbr
        JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
        WHERE pbr.profile_id = p.id),
        '[]'::json
      )
    ) FROM profiles p WHERE p.id = r.created_by) AS author,
    (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS update_count,
    (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS comment_count
  FROM research r
  WHERE
    (search_query IS NULL OR r.fts @@ ts_query) AND
    (category_id IS NULL OR r.category = category_id) AND
    (research_status IS NULL OR r.status = research_status) AND
    (r.is_draft IS NULL OR r.is_draft = FALSE) AND
    (r.deleted IS NULL OR r.deleted = FALSE)
  ORDER BY
    -- Add relevance ranking when search query is provided
    CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(r.fts, ts_query) END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'Newest' THEN extract(epoch from r.created_at)
      WHEN sort_by = 'LatestUpdated' THEN extract(epoch from
        GREATEST(
          r.modified_at,
          COALESCE(
            (SELECT MAX(ru.modified_at) FROM research_updates ru
             WHERE ru.research_id = r.id
               AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
               AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
            r.modified_at
          )
        )
      )
      WHEN sort_by = 'MostComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      WHEN sort_by = 'MostUseful' THEN
        (SELECT COALESCE(COUNT(uv.id), 0) FROM useful_votes uv WHERE uv.content_id = r.id AND uv.content_type = 'research')
      WHEN sort_by = 'MostUpdates' THEN
        (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      ELSE 0
    END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'LeastComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
    END ASC NULLS LAST,
    r.created_at DESC
  LIMIT limit_val OFFSET offset_val;
END;
$function$
;

