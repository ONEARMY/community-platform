CREATE TABLE IF NOT EXISTS "public"."comments" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text") NOT NULL,
    "comment" "text" NOT NULL,
    "source_id" bigint,
    "parent_id" bigint,
    "tenant_id" "text" DEFAULT ''::"text" NOT NULL,
    "created_by" bigint,
    "source_type" "text" NOT NULL,
    "modified_at" timestamp with time zone,
    "source_id_legacy" "text",
    "deleted" boolean,
    "legacy_id" "text"
);

CREATE INDEX "comments_created_by_idx" ON "public"."comments" USING "btree" ("created_by");
CREATE INDEX "comments_source_type_source_id_created_at_idx" ON "public"."comments" USING "btree" ("source_type", "source_id", "created_at");

ALTER TABLE ONLY "public"."comments"
    ADD CONSTRAINT "comment_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE "public"."comments" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tenant_isolation" ON "public"."comments" USING (("tenant_id" = (SELECT (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text"))));

CREATE OR REPLACE FUNCTION "public"."comment_authors_by_source_id"("source_id_input" bigint) RETURNS SETOF "text"
    LANGUAGE "sql"
    SET search_path = public, pg_temp
    AS $$
  SELECT DISTINCT (p.username)
  FROM comments c
  INNER JOIN profiles p
  ON c.created_by = p.id
  WHERE c.source_id = source_id_input
$$;

CREATE OR REPLACE FUNCTION "public"."get_comments_with_votes"("p_source_type" "text", "p_source_id" bigint, "p_current_user_id" bigint DEFAULT NULL::bigint) RETURNS TABLE("id" bigint, "comment" "text", "created_at" timestamp with time zone, "modified_at" timestamp with time zone, "deleted" boolean, "source_id" bigint, "source_type" "text", "parent_id" bigint, "created_by" bigint, "profile" "json", "vote_count" bigint, "has_voted" boolean)
    LANGUAGE "plpgsql"
    SET search_path = public, pg_temp
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id,
    c.comment,
    c.created_at,
    c.modified_at,
    c.deleted,
    c.source_id,
    c.source_type,
    c.parent_id,
    c.created_by,
    -- Build the profile JSON structure
    CASE 
      WHEN p.id IS NOT NULL THEN 
        json_build_object(
          'id', p.id,
          'display_name', p.display_name,
          'username', p.username,
          'photo', p.photo,
          'country', p.country,
          'badges', COALESCE(badges_agg.badges_array, '[]'::json)
        )
      ELSE NULL 
    END as profile,
    -- Count of useful votes for this comment
    COALESCE(vote_counts.vote_count, 0) as vote_count,
    -- Whether current user has voted on this comment
    CASE 
      WHEN p_current_user_id IS NOT NULL AND user_votes.content_id IS NOT NULL 
      THEN TRUE 
      ELSE FALSE 
    END as has_voted
  FROM comments c
  LEFT JOIN profiles p ON c.created_by = p.id
  -- Aggregate badges for each profile
  LEFT JOIN (
    SELECT 
      pbr.profile_id,
      json_agg(
        json_build_object(
          'id', pb.id,
          'name', pb.name,
          'display_name', pb.display_name,
          'image_url', pb.image_url,
          'action_url', pb.action_url
        )
      ) as badges_array
    FROM profile_badges_relations pbr
    JOIN profile_badges pb ON pbr.profile_badge_id = pb.id
    GROUP BY pbr.profile_id
  ) badges_agg ON p.id = badges_agg.profile_id
  -- Count useful votes for each comment
  LEFT JOIN (
    SELECT 
      uv.content_id,
      COUNT(*) as vote_count
    FROM useful_votes uv
    WHERE uv.content_type = 'comments'
    GROUP BY uv.content_id
  ) vote_counts ON c.id = vote_counts.content_id
  -- Check if current user has voted on each comment
  LEFT JOIN (
    SELECT DISTINCT uv.content_id
    FROM useful_votes uv
    WHERE uv.content_type = 'comments'
      AND uv.user_id = p_current_user_id
  ) user_votes ON c.id = user_votes.content_id
  WHERE 
    c.source_type = p_source_type
    AND c.source_id = p_source_id
  ORDER BY c.created_at ASC;
END;
$$;

CREATE OR REPLACE FUNCTION "public"."update_comment_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET search_path = public, pg_temp
    AS $$BEGIN
  IF (TG_OP = 'INSERT') THEN
    IF NEW.source_type IS NOT NULL AND NEW.source_id IS NOT NULL AND (NEW.deleted IS NULL OR NEW.deleted = false) THEN
      IF NEW.source_type = 'questions' THEN
        UPDATE questions SET comment_count = COALESCE(comment_count, 0) + 1
        WHERE id = NEW.source_id;
      ELSIF NEW.source_type = 'research_update' THEN
        UPDATE research_updates SET comment_count = COALESCE(comment_count, 0) + 1
        WHERE id = NEW.source_id;
      ELSIF NEW.source_type = 'news' THEN
        UPDATE news SET comment_count = COALESCE(comment_count, 0) + 1
        WHERE id = NEW.source_id;
      ELSIF NEW.source_type = 'projects' THEN
        UPDATE projects SET comment_count = COALESCE(comment_count, 0) + 1
        WHERE id = NEW.source_id;
      END IF;
    ELSE
      RAISE NOTICE 'Warning: source_type or source_id is NULL, or comment is deleted';
    END IF;
  ELSIF (TG_OP = 'UPDATE') THEN
    IF (COALESCE(OLD.deleted, false) = false AND NEW.deleted = true) THEN
      IF OLD.source_type IS NOT NULL AND OLD.source_id IS NOT NULL THEN
        IF OLD.source_type = 'questions' THEN
          UPDATE questions SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
          WHERE id = OLD.source_id;
        ELSIF OLD.source_type = 'research_update' THEN
          UPDATE research_updates SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
          WHERE id = OLD.source_id;
        ELSIF OLD.source_type = 'news' THEN
          UPDATE news SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
          WHERE id = OLD.source_id;
        ELSIF OLD.source_type = 'projects' THEN
          UPDATE projects SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
          WHERE id = OLD.source_id;
        END IF;
      ELSE
        RAISE NOTICE 'Warning: OLD.source_type or OLD.source_id is NULL';
      END IF;
    ELSIF (OLD.deleted = true AND COALESCE(NEW.deleted, false) = false) THEN
      IF NEW.source_type IS NOT NULL AND NEW.source_id IS NOT NULL THEN
        IF NEW.source_type = 'questions' THEN
          UPDATE questions SET comment_count = COALESCE(comment_count, 0) + 1
          WHERE id = NEW.source_id;
        ELSIF NEW.source_type = 'research_update' THEN
          UPDATE research_updates SET comment_count = COALESCE(comment_count, 0) + 1
          WHERE id = NEW.source_id;
        ELSIF NEW.source_type = 'news' THEN
          UPDATE news SET comment_count = COALESCE(comment_count, 0) + 1
          WHERE id = NEW.source_id;
        ELSIF NEW.source_type = 'projects' THEN
          UPDATE projects SET comment_count = COALESCE(comment_count, 0) + 1
          WHERE id = NEW.source_id;
        END IF;
      ELSE
        RAISE NOTICE 'Warning: NEW.source_type or NEW.source_id is NULL';
      END IF;
    END IF;
  ELSIF (TG_OP = 'DELETE') THEN
    IF OLD.source_type IS NOT NULL AND OLD.source_id IS NOT NULL THEN
      IF OLD.source_type = 'questions' THEN
        UPDATE questions SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
        WHERE id = OLD.source_id;
      ELSIF OLD.source_type = 'research_update' THEN
        UPDATE research_updates SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
        WHERE id = OLD.source_id;
      ELSIF OLD.source_type = 'news' THEN
        UPDATE news SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
        WHERE id = OLD.source_id;
      ELSIF OLD.source_type = 'projects' THEN
        UPDATE projects SET comment_count = GREATEST(COALESCE(comment_count, 0) - 1, 0)
        WHERE id = OLD.source_id;
      END IF;
    ELSE
      RAISE NOTICE 'Warning: OLD.source_type or OLD.source_id is NULL';
    END IF;
  END IF;
  
  RETURN NULL;
END;$$;

CREATE OR REPLACE TRIGGER "update_comment_count" AFTER INSERT OR DELETE OR UPDATE ON "public"."comments" FOR EACH ROW EXECUTE FUNCTION "public"."update_comment_count"();
