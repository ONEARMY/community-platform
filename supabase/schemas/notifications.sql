CREATE TYPE "public"."notification_action_types" AS ENUM (
    'newComment',
    'newContent'
);
ALTER TYPE "public"."notification_action_types" OWNER TO "postgres";

CREATE TYPE "public"."notification_content_types" AS ENUM (
    'news',
    'research',
    'researchUpdate',
    'library',
    'questions',
    'comment',
    'reply'
);
ALTER TYPE "public"."notification_content_types" OWNER TO "postgres";

CREATE TYPE "public"."notification_source_content_type" AS ENUM (
    'news',
    'research',
    'researchUpdate',
    'library',
    'questions'
);
ALTER TYPE "public"."notification_source_content_type" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text") NOT NULL,
    "modified_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text"),
    "owned_by_id" bigint NOT NULL,
    "triggered_by_id" bigint NOT NULL,
    "content_type" "public"."notification_content_types" NOT NULL,
    "content_id" bigint NOT NULL,
    "is_read" boolean DEFAULT false,
    "action_type" "public"."notification_action_types" NOT NULL,
    "tenant_id" "text" NOT NULL,
    "source_content_type" "text",
    "source_content_id" bigint,
    "parent_comment_id" bigint,
    "parent_content_id" bigint,
    "should_email" boolean
);

CREATE TABLE IF NOT EXISTS "public"."notifications_preferences" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "user_id" bigint NOT NULL,
    "comments" boolean NOT NULL,
    "replies" boolean NOT NULL,
    "tenant_id" "text" NOT NULL,
    "research_updates" boolean NOT NULL,
    "is_unsubscribed" boolean DEFAULT false NOT NULL
);

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_owned_by_id_fkey" FOREIGN KEY ("owned_by_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "public"."notifications_preferences"
    ADD CONSTRAINT "notifications_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_triggered_by_id_fkey" FOREIGN KEY ("triggered_by_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE;

ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."notifications_preferences" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tenant_isolation" ON "public"."notifications" USING (("tenant_id" = ((SELECT current_setting('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text")));
CREATE POLICY "tenant_isolation" ON "public"."notifications_preferences" USING (("tenant_id" = ((SELECT current_setting('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text")));

CREATE OR REPLACE FUNCTION public.get_subscribed_users_emails_to_notify(p_content_id bigint, p_content_type text)
 RETURNS TABLE(
    email character varying,
    profile_id bigint,
    profile_created_at timestamp with time zone,
    display_name character varying,
    comments boolean,
    replies boolean,
    research_updates boolean,
    is_unsubscribed boolean
)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT DISTINCT ON (p.id)
        u.email,
        p.id AS profile_id,
        p.created_at AS profile_created_at,
        p.display_name::character varying,
        np.comments,
        np.replies,
        np.research_updates,
        np.is_unsubscribed
    FROM subscribers s
    INNER JOIN profiles p ON s.user_id = p.id
    INNER JOIN auth.users u ON p.auth_id = u.id
    LEFT JOIN notifications_preferences np ON np.user_id = p.id
    WHERE s.content_id = p_content_id AND s.content_type = p_content_type
    ORDER BY p.id;
END;
$function$
;