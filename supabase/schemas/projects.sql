CREATE TABLE IF NOT EXISTS "public"."project_steps" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text") NOT NULL,
    "project_id" bigint NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "images" "json",
    "video_url" "text",
    "order" smallint,
    "tenant_id" "text" NOT NULL
);

CREATE TABLE IF NOT EXISTS "public"."projects" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text") NOT NULL,
    "modified_at" timestamp with time zone,
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "previous_slugs" "text"[],
    "description" "text" NOT NULL,
    "created_by" bigint,
    "deleted" boolean,
    "category" bigint,
    "difficulty_level" "text",
    "cover_image" "json",
    "file_link" "text",
    "files" "json"[],
    "tags" "text"[],
    "is_draft" boolean,
    "time" "text",
    "file_download_count" integer,
    "moderation" "text",
    "moderation_feedback" "text",
    "tenant_id" "text" NOT NULL,
    "fts" "tsvector",
    "total_views" bigint,
    "comment_count" integer,
    "legacy_id" "text"
);

ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_slug_key" UNIQUE ("slug", "tenant_id");

ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_title_key" UNIQUE ("title", "tenant_id");

CREATE INDEX "projects_created_by_idx" ON "public"."projects" USING "btree" ("created_by");


ALTER TABLE ONLY "public"."project_steps"
    ADD CONSTRAINT "project_steps_project_id_fkey" FOREIGN KEY ("project_id") REFERENCES "public"."projects"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_category_id_fkey" FOREIGN KEY ("category") REFERENCES "public"."categories"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "public"."projects"
    ADD CONSTRAINT "projects_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE "public"."project_steps" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."projects" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tenant_isolation" ON "public"."project_steps" USING (("tenant_id" = (SELECT (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text"))));
CREATE POLICY "tenant_isolation" ON "public"."projects" USING (("tenant_id" = (SELECT (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text"))));


CREATE OR REPLACE FUNCTION "public"."combined_project_search_fields"("project_id_param" bigint) RETURNS "text"
    LANGUAGE "sql"
    AS $$
  SELECT
    (SELECT p.title || ' ' || p.description FROM projects p WHERE p.id = project_id_param) || ' ' ||
    COALESCE(string_agg(ps.title || ' ' || ps.description, ' '), '')
  FROM project_steps ps
  WHERE ps.project_id = project_id_param;
$$;

CREATE OR REPLACE FUNCTION "public"."get_projects"("search_query" "text" DEFAULT NULL::"text", "category_id" bigint DEFAULT NULL::bigint, "sort_by" "text" DEFAULT 'Newest'::"text", "limit_val" integer DEFAULT 12, "offset_val" integer DEFAULT 0, "current_username" "text" DEFAULT NULL::"text") RETURNS TABLE("id" bigint, "created_at" timestamp with time zone, "created_by" bigint, "modified_at" timestamp with time zone, "description" "text", "slug" "text", "cover_image" "json", "category" "json", "tags" "text"[], "title" "text", "moderation" "text", "total_views" bigint, "author" "json", "comment_count" integer)
    LANGUAGE "plpgsql"
    AS $$DECLARE
    ts_query tsquery;
BEGIN
    -- Parse search query once if provided
    IF search_query IS NOT NULL THEN
        ts_query := to_tsquery('english', search_query);
    END IF;
    
    RETURN QUERY
    SELECT
        p.id,
        p.created_at,
        p.created_by,
        p.modified_at,
        p.description,
        p.slug,
        p.cover_image,
        (SELECT json_build_object('id', c.id, 'name', c.name)
         FROM categories c
         WHERE c.id = p.category) AS category,
        p.tags,
        p.title,
        p.moderation,
        p.total_views,
        (SELECT json_build_object(
          'id', prof.id,
          'display_name', prof.display_name,
          'username', prof.username,
          'country', prof.country,
          'badges', COALESCE(
            (SELECT json_agg(
              json_build_object(
                'id', pb.id,
                'name', pb.name,
                'display_name', pb.display_name,
                'image_url', pb.image_url,
                'action_url', pb.action_url
                )
              )
              FROM profile_badges_relations pbr
              JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
              WHERE pbr.profile_id = prof.id),
              '[]'::json
          )
        ) FROM profiles prof WHERE prof.id = p.created_by) AS author,
        p.comment_count
    FROM projects p
    JOIN profiles prof ON prof.id = p.created_by  -- Add explicit JOIN
    WHERE
        (search_query IS NULL OR
         p.fts @@ ts_query OR
         prof.username ILIKE '%' || search_query || '%'
        ) AND
        (category_id IS NULL OR p.category = category_id) AND
        (p.is_draft IS NULL OR p.is_draft = FALSE) AND
        (p.deleted IS NULL OR p.deleted = FALSE) AND
        (p.moderation = 'accepted' OR prof.username = current_username)
    ORDER BY
        -- Add relevance ranking when search query is provided
        CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(p.fts, ts_query) END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'Newest' THEN extract(epoch from p.created_at)
            WHEN sort_by = 'LatestUpdated' THEN extract(epoch from p.modified_at)
            WHEN sort_by = 'MostComments' THEN p.comment_count
            WHEN sort_by = 'MostDownloads' THEN p.file_download_count
            WHEN sort_by = 'MostUseful' THEN
                (SELECT COALESCE(COUNT(uv.id), 0)
                 FROM useful_votes uv
                 WHERE uv.content_id = p.id AND uv.content_type = 'projects')
            ELSE 0
        END DESC NULLS LAST,
        CASE
            WHEN sort_by = 'LeastComments' THEN p.comment_count
        END ASC NULLS LAST,
        p.created_at DESC
    LIMIT limit_val OFFSET offset_val;
END;$$;

CREATE OR REPLACE FUNCTION "public"."get_projects_count"("search_query" "text" DEFAULT NULL::"text", "category_id" integer DEFAULT NULL::integer, "current_username" "text" DEFAULT NULL::"text") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  ts_query tsquery;
BEGIN
    IF search_query IS NOT NULL THEN
      ts_query := to_tsquery('english', search_query);
    END IF;

  RETURN (
    SELECT COUNT(*)
    FROM projects p
    INNER JOIN profiles prof ON prof.id = p.created_by
    WHERE
      (category_id IS NULL OR p.category = category_id) AND
      (p.is_draft IS NULL OR p.is_draft = FALSE) AND
      (p.deleted IS NULL OR p.deleted = FALSE) AND
      (p.moderation = 'accepted' OR prof.username = current_username)
  );
END;
$$;

CREATE OR REPLACE FUNCTION "public"."get_user_projects"("username_param" "text") RETURNS TABLE("id" bigint, "title" "text", "slug" "text", "total_useful" bigint)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pr.id,
    pr.title,
    pr.slug,
    COALESCE(COUNT(uv.id), 0)::BIGINT AS total_useful
  FROM projects pr
  INNER JOIN profiles p ON p.id = pr.created_by
  LEFT JOIN useful_votes uv ON uv.content_id = pr.id AND uv.content_type = 'projects'
  WHERE p.username = username_param
  AND (pr.deleted IS NULL OR pr.deleted = FALSE)
  AND (pr.is_draft IS NULL OR pr.is_draft = FALSE)
  AND (pr.moderation = 'accepted')
  GROUP BY pr.id, pr.title, pr.slug;
END;
$$;

CREATE OR REPLACE FUNCTION "public"."update_project_tsvector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_TABLE_NAME = 'project_steps' THEN
    UPDATE projects
    SET fts = to_tsvector('english', public.combined_project_search_fields(NEW.project_id))
    WHERE id = NEW.project_id;
  ELSEIF TG_TABLE_NAME = 'projects' THEN
    UPDATE projects
    SET fts = to_tsvector('english', public.combined_project_search_fields(NEW.id))
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER "project_step_trigger" AFTER INSERT OR DELETE OR UPDATE OF "title", "description" ON "public"."project_steps" FOR EACH ROW EXECUTE FUNCTION "public"."update_project_tsvector"();
CREATE OR REPLACE TRIGGER "project_text_trigger" AFTER INSERT OR UPDATE OF "title", "description" ON "public"."projects" FOR EACH ROW EXECUTE FUNCTION "public"."update_project_tsvector"();
