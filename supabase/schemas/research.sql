CREATE TYPE "public"."research_status" AS ENUM (
    'in-progress',
    'complete',
    'archived'
);

CREATE TABLE IF NOT EXISTS "public"."research" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "modified_at" timestamp with time zone DEFAULT "now"(),
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text" NOT NULL,
    "category" bigint,
    "created_by" bigint,
    "tags" "text"[],
    "deleted" boolean,
    "total_views" integer,
    "total_useful" integer,
    "previous_slugs" "text"[],
    "status" "public"."research_status",
    "is_draft" boolean,
    "tenant_id" "text" NOT NULL,
    "fts" "tsvector",
    "collaborators" "text"[],
    "image" "json",
    "legacy_id" "text"
);

CREATE TABLE IF NOT EXISTS "public"."research_updates" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text") NOT NULL,
    "research_id" bigint NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "images" "json"[],
    "files" "json"[],
    "video_url" "text",
    "is_draft" boolean,
    "comment_count" integer,
    "tenant_id" "text" NOT NULL,
    "modified_at" timestamp with time zone DEFAULT ("now"() AT TIME ZONE 'utc'::"text"),
    "deleted" boolean,
    "file_link" "text",
    "file_download_count" integer,
    "created_by" bigint,
    "legacy_id" "text"
);

CREATE INDEX "research_created_by_idx" ON "public"."research" USING "btree" ("created_by");
CREATE INDEX "research_fts_idx" ON "public"."research" USING "gin" ("fts");
CREATE INDEX "research_updates_created_by_idx" ON "public"."research_updates" USING "btree" ("created_by");

ALTER TABLE ONLY "public"."research"
    ADD CONSTRAINT "research_category_fkey" FOREIGN KEY ("category") REFERENCES "public"."categories"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "public"."research"
    ADD CONSTRAINT "research_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "public"."research_updates"
    ADD CONSTRAINT "research_update_research_id_fkey" FOREIGN KEY ("research_id") REFERENCES "public"."research"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."research_updates"
    ADD CONSTRAINT "research_updates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE "public"."research" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."research_updates" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tenant_isolation" ON "public"."research" USING (("tenant_id" = (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text")));
CREATE POLICY "tenant_isolation" ON "public"."research_updates" USING (("tenant_id" = (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text")));


CREATE OR REPLACE FUNCTION "public"."combined_research_search_fields"("research_id_param" bigint) RETURNS "text"
    LANGUAGE "sql"
    AS $$
  SELECT
    (SELECT r.title || ' ' || r.description FROM research r WHERE r.id = research_id_param) || ' ' ||
    COALESCE(string_agg(ru.title || ' ' || ru.description, ' '), '')
  FROM research_updates ru
  WHERE ru.research_id = research_id_param;
$$;

CREATE OR REPLACE FUNCTION "public"."get_research"("search_query" "text" DEFAULT NULL::"text", "category_id" bigint DEFAULT NULL::bigint, "research_status" "public"."research_status" DEFAULT NULL::"public"."research_status", "sort_by" "text" DEFAULT 'Newest'::"text", "limit_val" integer DEFAULT 10, "offset_val" integer DEFAULT 0) RETURNS TABLE("id" bigint, "created_at" timestamp with time zone, "created_by" bigint, "modified_at" timestamp with time zone, "description" "text", "slug" "text", "image" "json", "status" "public"."research_status", "category" "json", "tags" "text"[], "title" "text", "total_views" integer, "author" "json", "update_count" bigint, "comment_count" bigint)
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  ts_query tsquery;
BEGIN
  -- Parse the search query once if provided
  IF search_query IS NOT NULL THEN
    ts_query := to_tsquery('english', search_query);
  END IF;
 
  RETURN QUERY
  SELECT
    r.id,
    r.created_at,
    r.created_by,
    GREATEST(
      r.modified_at,
      COALESCE(
        (SELECT MAX(ru.modified_at) FROM research_updates ru
         WHERE ru.research_id = r.id
           AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
           AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
        r.modified_at
      )
    ) AS modified_at,
    r.description,
    r.slug,
    r.image,
    r.status,
    (SELECT json_build_object('id', c.id, 'name', c.name) FROM categories c WHERE c.id = r.category) AS category,
    r.tags,
    r.title,
    r.total_views,
    (SELECT json_build_object(
      'id', p.id,
      'display_name', p.display_name,
      'username', p.username,
      'country', p.country,
      'badges', COALESCE(
        (SELECT json_agg(
          json_build_object(
            'id', pb.id,
            'name', pb.name,
            'display_name', pb.display_name,
            'image_url', pb.image_url,
            'action_url', pb.action_url
          )
        )
        FROM profile_badges_relations pbr
        JOIN profile_badges pb ON pb.id = pbr.profile_badge_id
        WHERE pbr.profile_id = p.id),
        '[]'::json
      )
    ) FROM profiles p WHERE p.id = r.created_by) AS author,
    (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS update_count,
    (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE)) AS comment_count
  FROM research r
  WHERE
    (search_query IS NULL OR r.fts @@ ts_query) AND
    (category_id IS NULL OR r.category = category_id) AND
    (research_status IS NULL OR r.status = research_status) AND
    (r.is_draft IS NULL OR r.is_draft = FALSE) AND
    (r.deleted IS NULL OR r.deleted = FALSE)
  ORDER BY
    -- Add relevance ranking when search query is provided
    CASE WHEN search_query IS NOT NULL THEN ts_rank_cd(r.fts, ts_query) END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'Newest' THEN extract(epoch from r.created_at)
      WHEN sort_by = 'LatestUpdated' THEN extract(epoch from
        GREATEST(
          r.modified_at,
          COALESCE(
            (SELECT MAX(ru.modified_at) FROM research_updates ru
             WHERE ru.research_id = r.id
               AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
               AND (ru.deleted IS NULL OR ru.deleted = FALSE)),
            r.modified_at
          )
        )
      )
      WHEN sort_by = 'MostComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      WHEN sort_by = 'MostUseful' THEN
        (SELECT COALESCE(COUNT(uv.id), 0) FROM useful_votes uv WHERE uv.content_id = r.id AND uv.content_type = 'research')
      WHEN sort_by = 'MostUpdates' THEN
        (SELECT COUNT(*) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
      ELSE 0
    END DESC NULLS LAST,
    CASE
      WHEN sort_by = 'LeastComments' THEN
        (SELECT COALESCE(SUM(ru.comment_count), 0) FROM research_updates ru WHERE ru.research_id = r.id AND (ru.is_draft IS NULL OR ru.is_draft = FALSE)
          AND (ru.deleted IS NULL OR ru.deleted = FALSE))
    END ASC NULLS LAST,
    r.created_at DESC
  LIMIT limit_val OFFSET offset_val;
END;
$$;

CREATE OR REPLACE FUNCTION "public"."get_research_count"("search_query" "text" DEFAULT NULL::"text", "category_id" integer DEFAULT NULL::integer, "research_status" "public"."research_status" DEFAULT NULL::"public"."research_status") RETURNS integer
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM research r
    WHERE
      (search_query IS NULL OR r.fts @@ to_tsquery('english', search_query)) AND
      (category_id IS NULL OR r.category = category_id) AND
      (research_status IS NULL OR r.status = research_status) AND
      (r.is_draft IS NULL OR r.is_draft = FALSE) AND
      (r.deleted IS NULL OR r.deleted = FALSE)
  );
END;
$$;

CREATE OR REPLACE FUNCTION "public"."get_user_research"("username_param" "text") RETURNS TABLE("id" bigint, "title" "text", "slug" "text", "total_useful" bigint)
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    r.id,
    r.title,
    r.slug,
    COALESCE(COUNT(uv.id), 0)::BIGINT AS total_useful
  FROM research r
  INNER JOIN profiles p ON p.id = r.created_by
  LEFT JOIN useful_votes uv ON uv.content_id = r.id AND uv.content_type = 'research'
  WHERE p.username = username_param
  AND (r.deleted IS NULL OR r.deleted = FALSE)
  AND (r.is_draft IS NULL OR r.is_draft = FALSE)
  GROUP BY r.id, r.title, r.slug;
END;
$$;

CREATE OR REPLACE FUNCTION "public"."update_research_tsvector"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF TG_TABLE_NAME = 'research_updates' THEN
    UPDATE research
    SET fts = to_tsvector('english', public.combined_research_search_fields(NEW.research_id))
    WHERE id = NEW.research_id;
  ELSEIF TG_TABLE_NAME = 'research' THEN
    UPDATE research
    SET fts = to_tsvector('english', public.combined_research_search_fields(NEW.id))
    WHERE id = NEW.id;
  END IF;
  RETURN NEW;
END;
$$;

CREATE OR REPLACE TRIGGER "research_text_trigger" AFTER INSERT OR UPDATE OF "title", "description" ON "public"."research" FOR EACH ROW EXECUTE FUNCTION "public"."update_research_tsvector"();
CREATE OR REPLACE TRIGGER "research_update_trigger" AFTER INSERT OR DELETE OR UPDATE OF "title", "description" ON "public"."research_updates" FOR EACH ROW EXECUTE FUNCTION "public"."update_research_tsvector"();
