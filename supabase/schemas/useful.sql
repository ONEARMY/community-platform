CREATE TYPE "public"."useful_content_types" AS ENUM (
    'questions',
    'projects',
    'research',
    'news',
    'comments'
);

CREATE TABLE IF NOT EXISTS "public"."useful_votes" (
    "id" bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "content_id" bigint NOT NULL,
    "content_type" "public"."useful_content_types" NOT NULL,
    "user_id" bigint NOT NULL,
    "tenant_id" "text" NOT NULL
);

CREATE INDEX "useful_votes_comments_content_id_idx" ON "public"."useful_votes" USING "btree" ("content_id") WHERE ("content_type" = 'comments'::"public"."useful_content_types");
CREATE INDEX "useful_votes_comments_user_id_content_id_idx" ON "public"."useful_votes" USING "btree" ("user_id", "content_id") WHERE ("content_type" = 'comments'::"public"."useful_content_types");
CREATE INDEX "useful_votes_content_type_content_id_idx" ON "public"."useful_votes" USING "btree" ("content_type", "content_id");

ALTER TABLE ONLY "public"."useful_votes"
    ADD CONSTRAINT "useful_votes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE "public"."useful_votes" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tenant_isolation" ON "public"."useful_votes" USING (("tenant_id" = (SELECT (("current_setting"('request.headers'::"text", true))::"json" ->> 'x-tenant-id'::"text"))));

CREATE OR REPLACE FUNCTION "public"."get_author_vote_counts"("author_id" bigint) RETURNS TABLE("content_type" "text", "vote_count" bigint)
    LANGUAGE "sql" STABLE
    SET search_path = public, pg_temp
    AS $$
    SELECT 
        uv.content_type,
        COUNT(*) as vote_count
    FROM useful_votes uv
    WHERE (uv.content_type = 'questions' AND EXISTS (
        SELECT 1 FROM questions q WHERE q.id = uv.content_id AND q.created_by = author_id and (q.deleted is null or q.deleted = false)
    ))
    OR (uv.content_type = 'projects' AND EXISTS (
        SELECT 1 FROM projects p WHERE p.id = uv.content_id AND p.created_by = author_id and (p.deleted is null or p.deleted = false)
    ))
    OR (uv.content_type = 'news' AND EXISTS (
        SELECT 1 FROM news n WHERE n.id = uv.content_id AND n.created_by = author_id and (n.deleted is null or n.deleted = false)
    ))
    OR (uv.content_type = 'research' AND EXISTS (
        SELECT 1 FROM research r WHERE r.id = uv.content_id AND r.created_by = author_id and (r.deleted is null or r.deleted = false)
    ))
    GROUP BY uv.content_type
    ORDER BY vote_count DESC;
$$;

CREATE OR REPLACE FUNCTION "public"."get_useful_votes_count_by_content_id"("p_content_type" "public"."useful_content_types", "p_content_ids" bigint[]) RETURNS TABLE("content_id" bigint, "count" bigint)
    LANGUAGE "plpgsql"
    SET search_path = public, pg_temp
    AS $$
BEGIN
  RETURN QUERY
  SELECT v.content_id, COUNT(*) as count
  FROM public.useful_votes v
  WHERE v.content_type = p_content_type
    AND v.content_id = ANY(p_content_ids)
  GROUP BY v.content_id;
END;
$$;

